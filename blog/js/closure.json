{
	"template": "./template.thtml",
	"title": "读Javascript Closures文章",
	"time": "2014-02-18",
	"classify": "Javascript",
	"tag": "",
	"content": [
		"CONTENT{英文原文链接：http://jibbering.com/faq/notes/closures/}",
		"CONTENT{据说，打开这个网页剧慢无比……英文原文LZ蛋疼到微盘了：http://vdisk.weibo.com/s/sX848 中文翻译也丢到微盘了：http://vdisk.weibo.com/s/sX84A}",
		"CONTENT{以下是LZ阅读该文后、认为比较好玩的东西，特此不要脸的扯淡下。}",
		"CONTENT{1. 对象命名属性的解析：对于已经存在的属性，就不会再有申明（请睁亮你的氪金狗眼，是“申明”！）的事了。最明显的是，曾经RIA群里讨论过这么一个问题：}",
		"IMAGE{../images/blog/closure/closure_1.png}",
		"CONTENT{问为啥没有报错。其实，全局在很久以前就有Array这个属性了，所以呢，这里的var是没有任何意义的。}",
		"CONTENT{2. 对象属性值的读取是沿着原型链的：这个是个前端的都知道，需要说一下的是，对象属性的赋值对原型链中的同名属性没有任何影响。}",
		"CONTENT{3. 所有的javascript代码都在某个执行上下文中执行。执行上下文创建时，按顺序干了很多事：}",
		"CONTENT{3.1 创建“Activation”对象（活动对象），这货说是对象，但是，没有原型。而且，不能通过代码直接访问。}",
		"CONTENT{3.2 创建“arguments”对象，这个就是传说中的function里的arguments类数组。实际上，Activation对象也有一个同名属性arguments，指向了这货。}",
		"CONTENT{3.3 分配作用域。作用域包含一个链，人称作用域链，链上的每个对象都有一个内置的[[scope]]属性，这货又是一个链……而Activation对象则在作用域链的顶部。}",
		"CONTENT{3.4 变量实例化。变量的实例化都在Variable对象上，在Variable对象上干这几件事：首先，为每个形参创建对应的属性，函数调用时候，实参值会赋给这些属性，没有传入的自然就是undefined了；其次，为所有的内部函数申明（请再次睁亮你的氪金狗眼，是“函数申明”！）创建对应的属性，属性名就是函数名，属性值就是函数对象；最后，为函数局部变量创建对应的命名属性。（看到这里，知道为毛JS世界里谣言着这么一句话：js运行时，会将var都提到最前……了吧，我曾经微博过： http://weibo.com/2000064541/zo9xyaIBo 其实，不叫“提到最前”，这句话是有误的，只是一种绝大多数情况是对的时候的简单理解，下面会提到一点有误之处）。}",
		"CONTENT{3.5 this关键字赋值。如果分配的值引用了某个对象，那么以this关键字为前缀的属性访问器引用该对象的属性。如果分配的值为null，则this关键字引用全局对象。——这个是直译过来的，请看不懂的坚决不要继续纠结，对于this的理解，LZ觉得你已经够用了。}",
		"CONTENT{这就是整个过程，全局上下文跟function的局部上下文略有不同，它没有arguments对象。也就不需要Activation对象的属性引用它。}",
		"CONTENT{4. 作用域链。作用域链保存在函数对象的[[scope]]属性中。}",
		"CONTENT{5. (!!!) 使用Function构造函数创建的函数对象总是有一个[[scope]]属性，它引用的作用域链只包含全局对象（LZ很好奇，有多少人知道这么个事的。年轻时候，LZ一直没用Function，在看那文章后才知道有这么大一坑）。}",
		"CONTENT{6. 通过函数申明或者函数表达式创建的函数对象，其作用域链就是相应的执行上下文作用域链。这里顺带提一下“函数申明”（前面提到过）和“函数表达式”。用代码表示：}",
		"IMAGE{../images/blog/closure/closure_2.png}",
		"CONTENT{这两货的差别很大，简单提一点，函数申明在执行前已经存在函数对象，函数表达式则在执行前其值为undefined，这也是3.4中酱油关于“JS世界里的谣言”这个事实，在微博中说它是有误的。看一眼：}",
		"IMAGE{../images/blog/closure/closure_3.png}",
		"CONTENT{按照“谣言”说法，var会被提到最前，那上述yourSister();的执行结果应该是“Expression”，而实际上你们都知道的，结果应该是“Declare”。所以说，谣言“js运行时，会将var都提到最前”是不正确的……}",
		"CONTENT{似乎好像看起来……跟“作用域链”扯远了，哎，酱油真的不想谈这种东西，你们都懂的，你们肯定懂的，是个JS人，都理解。不懂的，去翻翻神书“Javascript高级程序设计”吧吧。}",
		"CONTENT{最后再提一点作用域链的东西，有两个家伙：with和try-catch，会修改作用域链。try-catch就不讲了，提一下with，这个是跟eval一样被JS人所唾弃的，吐一句：你是不敢用不会用唾弃呢，还是不想用唾弃呢……}",
		"IMAGE{../images/blog/closure/closure_4.png}",
		"CONTENT{上述代码中第一个console.log、yourSisterNo1和两个yourSisterNo2的运行结果分别是 “2”、“1”、“2”、“2”。对with这里提三点：1. with代码块执行时，会将with(X)中的X对象放入当前执行上下文作用域链的顶部；2. 函数申明不受第1点的限制，傻逼点的理解就是函数申明的作用域与with外层作用域相同。try-catch类似，catch(e)也会把e对象放到作用域链顶部；3. with中创建的东西在外层也可以访问，并且，对于函数表达式，外层调用时，其作用域链没有改变。}",
		"CONTENT{5. 闭包。这东西不写了，闭包可以说是用了上述提到的所有东西了，尤其是作用域链和原型链（这里没提）。}"
	]
}